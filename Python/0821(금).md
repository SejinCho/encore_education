## 8/21(금) 

#### 다형성(Polymorphism)

-------------------

> 다형성(Polymorphism)이란?

- 어떤 한 요소에 여러 개념을 넣어 놓는 것으로 일반적으로 오버라이딩(깥은 이름의 메소드가 여러 클래스에서 다른 가능을 하는 것)이나 오버로딩(같은 이름의 메소드가 인자의 개수가 자료형에 따라서 다른 기능을 하는 것)을 의미한다. 
- 다형 개념을 통해서 그로그램 안의 객체 간의 관계를 조직적으로 나타낼 수 있다.

![image-20200822103236497](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822103236497.png)



- 다음은 overloading을 구현한 코드이다. 파이썬의 함수는 기본적으로 매개인자 기본 자료형 타입을 선언하지 않기 때문에 overloading을 하고 있다.

![image-20200822103421605](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822103421605.png)

![image-20200822103431100](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822103431100.png)



- 다형성의 특징은 다음과 같다.
  - 여러 개의 클래스가 같은 이름의 메소드에 대하여 서로 다른 각자의 방법으로 작동할 수 있도록 하는 설계를 가진다.
  - 하나의 데이터 유형(선조 객체)의 변수로 여러 유현의 객체 참조(후손의 객체)가 가능하다.
  - 변수가 참조하는 객체의 유형에 맞는 메소드를 자동으로 호출할 수 있다.
  - 추상화를 이용하여 다양한 구현을 제공한다.
- 다형성을 위한 필요조건은 다음과 같다.
  - 상속관계의 클래스이면서 후손 클래스 객체에서 작동된다.
  - 후손클래스 객체의 메소드 호출은 선조클래스 유형의 변수를 통해야 하며 호출된 메소드는 선조클래스 멤버이어야 한다.
  - 선조클래스와 후손클래스에서 메소드의 원형이 같아야 한다.



> 추상화(abstract)

- 파이썬은 상속의 유형 중에 선조클래스의 속성과 구조를 그대로 가지면서 새로운 데이터 멤버변수와 멤버메소드를 추가해서 코드의 재사용을 하는 서브클래싱(Sub classing)형 상속과 선조클래스가 수행할 명령을 선언하고 후손클래스가 사속을 받아 선조 클래스의 객체를 후손클래스의 타입으로 대처를 하여 실행할 수 있게 해주는 서브타이핑(Sub typing)형을 지원한다.
- 파이썬의 서브파이핑은 추상클래스를 지원하며 duck typing을 지원한다.
- duck typing은 동적 타이핑의 한 종류로 duck 클래스를 객체 선언하면 duck가 생성되어 호출된다는 말로 객체의 변수 및 메소드의 집합이 객체의 타입을 결정하는 것을 말한다.
- 서브타이핑 시에 선조의 주소로 후손의 객체를 가지는 것이 아니라 추상클래스를 선언하고 재정의를 하면서 후손의 객체주소를 각각 생성해서 메소드를 실행하게 된다.
- 추상클래스란 한 개 이상의 추상메소드를 가진 클래스로 , 추상 메소드의 내용이 구현되지 않아 인스터스로 생성이 불가능하며, 상속을 통해 추상메소드를 구현해야 하는 것이 특징이다. 
- 파이썬에서는 ABCMeta는 Abstract Base Classes Meta Class의 줄임 말로, 추상클래스를 메타클래스를 이용해서 만들기 위해 사용된다.

```python
from abc import abstractmethod, ABCMeta
```



- 파이썬에서는 코드를 간결화하기 위해 클래스내에 멤버메소드 선언 바로 위에 데코레이션 설정해서 사용한다. 
  - @abstractmethod : 메소드를 추상메소드로 지정
  - @property : 메소드를 변수로 호출 할 수 있도록 지정
  - @staticmethod : 정적 메소드로 선언
  - @classmethod : 클래스 인스턴스 메소드로 선언



- 다음은 추상클래스를 선언한 프로그램이다. 클래스는 선조의 추상클래스가 추상메소드를 2개 선언하고 후손은 각 메소드를 재정의하여 각각의 특징을 가진 내용으로 코드를 기술한다.

![image-20200822105143812](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822105143812.png)

- 먼저 from abc import abstractmethod, ABCMeta를 선언하여 import abstractmenthod는 @abstractmethod를 선언하여 메소드를 추상메소드로 만들어서 후손 클래스를 재정의하도록 하고, ABCMeta는 클래스 선언할 때 클래스 명과 괄호 안에 metaclass = ABCMeta를 선언하여 추상클래스화 한다.
- 추상클래스로 선언된 Base클래스는 객체 생성을 할 수 없는 규칙을 가지기 때문에 x=Base() 형식의 객체를 생성할 수 없다.

![image-20200822110426427](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822110426427.png)

- 다음엔 후손 클래스를 만들어서 재정의 메소드를 선언한 객체 생성 후 각각의 재정의 메소드를 호출한다.

![image-20200822110944598](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822110944598.png)

![image-20200822110955703](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822110955703.png)



----------

#### Exception handling

-------

> Exception(예외)

- 예외처리는 예외를 방치하거나 에러로 인한 프로그램 수행 결과가 잘못 동적을 하는 것이 아니라, 에러를 잡고 처리하는 방법을 제공한다.
- python은 오류가 발생하면 실행을 멈추고 오류메시지를 내준다. 오류메시지는 오류가 발생한 정확한 위치, 오류의 종류와 간단한 설명으로 구성된다.
- 오류는 크게 syntax error와 semantic error로 나눌 수 있다.
  - syntax error(구문오류) : 파생 오류(parsing error)라고도 하며 프로그램이 문법에 맞지 않으면 발생하는 오류이다. 구문 오류가 발생하면 오류메시지가 표시된다. 오류를 발견한 지점은 줄 번호와 위치 표시로 정확하게 알 수 있다.
  - semantic error : 프로그램의 수행 중에 발생할 수 있는 error로 사전에 프로그래머가 예상해서 처리할 수 있는 가벼운 에러를 말한다. semantic error를 Exception이라고 한다.



- 다음은 간단한 구문오류를 리턴한 경우이다.

![image-20200822111415672](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822111415672.png)

- print("A")를 하지 않고 사용했을 때 문법이 오류라고 알려주는 것을 확인할 수 있다.



- 예외의 특징은 다음과 같이 정리할 수 있다.
  - 프로그램의 수행 중에 발생할 수 있는 error로 사전에 프로그래머가 예상해서 처리할 수 있는 가벼운 에러를 말한다.
  - 파이썬에서는 예외처리를 이용해서 더 이상 프로그램이 수행할 수 없는 상황이 발생했을 때 무조건 프로그램을 종료하지 않고, 사전에 프로그래머가 예상해서 처리할 수 있는 가벼운 에러는 적절히 대처하면서 실행하도록 잘성할 수 있다.
  - 예외처리는 예상할 수 있는 예외상황에 대비하여 코드를 작성하게 하므로써 프로그램의 실행이 원할하도록 구현하게 한다.



> Exception Handling (에외처리)

- 파이썬은 exception을 처리하는 방법은 발생한 곳에서 exception을 직접 처리(handle)한다. try ~ except, try ~ else, try ~ finally, try ~ else ~ finally로 각각 선언해서 사용한다.

```python
[표현]
try :
	<code block>
except 예외종류, 예외변수 : #예외 종류, 변수는 생략 가능
	<예외 발생 시 실행되는 문구>
else : 
	<예외가 발생하지 않았을 때 실행되는 문구>
finally : 
	<예외 발생 여부에 상관하지 않고 꼭 실행되는 문구>
```



- 예외 종류별로 여러 개의 예외처리 시설을 갖출 수 있지만, 한 번에 하나의 예외처리 시설만 선택되어 실행된다. 둘 이상의 예외에 대해서 동일한 처리를 하고 싶으면 예외 이름을 다음과 같이 튜플로 묶으면 된다.

```python
Ex) except (ValueError, TypeError, NameError) : 
	pass
```



- 간단한 Exception을 처리해보자. 0으로 나누게 되면 에러가 발생되는데 Try 구문을 이용해서 다음과 같이 예외를 처리한다.

![image-20200822112425247](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822112425247.png)

![image-20200822112436008](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822112436008.png)



- 만일 파이썬에서 발생된 에러 메시지를 확인하고 싶다면 다음과 같이 as를 사용하여 리턴되는 값을 e변수를 통해 출력한다.

![image-20200822112530942](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822112530942.png)

![image-20200822112542363](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822112542363.png)



- 예외가 발생했을 경우, Python에서는 예외 발생시 정보를 보유하고 있는 메소드를 활용할 수 있다. 다음은 파이썬에서 제공하는 정보를 가진 메소드를 출력하는 구문이다.

![image-20200822112815460](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822112815460.png)

![image-20200822112827463](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822112827463.png)



- 다음은 try ~else 구문을 이용한 예이다.
- 코드 절에서 예외가 발생하지 않을 때 else구문에서 작업이 수행하도록 하기 위하여 try구문에 else를 제공한다.

![image-20200822113116981](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822113116981.png)

![image-20200822113125928](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822113125928.png)



- 다음 코드는 예외를 except 구문에서 튜플로 묶어 처리되며 try ~ catch ~ finally 구문을 실행한 코드이다. a = int('string') 부분을 주석처리 했을 경우는 구문이 모두 출력되지만 a = int('string') 부분을 수행하게 되면 추적이 시작된다.

![image-20200822113432467](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822113432467.png)

![image-20200822113445650](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822113445650.png)



![image-20200822113518980](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822113518980.png)

![image-20200822113528332](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822113528332.png)



- 모든 예외를 캐치하고 세부 사항을 표시시키고 싶을 경우는 sys모듈을 사용하거나 추척코드를 활용할 수 있다. 먼저 sys모듈의 sys.exc_info()를 활용한 예이다. 클래스와 예외클래스 그리고 traceback 한 객체 정보도 표시된다.

![image-20200822113731985](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822113731985.png)

![image-20200822113738740](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822113738740.png)



- 다음은 traceback.print_exc()을 이용한 코드이다. 출력부부이 추적을 하면서 예외상황을 리턴해 주는 것을 확인할 수 있다. traceback은 스택 추적을 보거나 검색하는 모듈이다.

![image-20200822114029019](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822114029019.png)

![image-20200822114051583](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822114051583.png)



> 사용자 Exception

- 사용자 정의 exception을 만들기 위해서는 Exception class를 상속(extending)받아야 한다.
- 상속을 받아 구현한 사용자 정의 Exception은 raise를 이용하여 객체를 호출한다.
- raise는 파이썬에서 원하는 에러를 강제로 발생시킬 수 있는 키워드이다.

```python
raise 예외변수
raise 예외변수 [예외처리 문자열]
```



- 프로그래머는 raise문을 이용하여 특정 예외를 발생시킬 수 있다.

![image-20200822114614211](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822114614211.png)

![image-20200822114624560](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822114624560.png)

![image-20200822114637380](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822114637380.png)

![image-20200822114647761](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822114647761.png)



- 사용자 정의 예외 클래스를 구현하는 일반적인 방법은 Exception 클래스를 상속받아 구현한다.
- Exception 클래스의 서브 클래스 중 하나를 상속받아도 된다.
  - 사용자 정의 예외 발생 방법
    - 내장 예외 발생 방법과 동이랗게 raise [클래스의 인스턴스]와 같이 해당 예외 클래스의 인스턴스를 던진다.
  - 사용자 정의 예외를 잡는 방법
    - except [클래스 이름]과 같이 해당 예외 클래스 이름을 사용한다.



- 프로그래머가 정의한 사용자 예외를 만들어 보자.

![image-20200822115126738](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822115126738.png)

![image-20200822115133859](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822115133859.png)



> 예외 테스트 assert와 unittest 213p 

- assert

  - assert는 테스트를 실시하기 위한 예외로 기본적으로는 raise와 비슷하다. 단지 자신의 문법을 가지고 있어 특정 조건을 추족하는 경우에만 예외를 발생시킬 때 유용하게 사용된다.
  - 조건식이 True가 되면 아무 일도 일어나지 않지만, 조건식이 False로 되는 것은 "문제"라고 판된되므로 다음 오류 메시지와 함께 예외를 발생한다.

  ```python
  assert <조건식> <메시지>
  ```



- 예제

![image-20200822122346190](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822122346190.png)

![image-20200822122353007](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822122353007.png)



- unittest
  - unittest는 python의 표준 패키지로 수행되는 코드 및 프로그램 단위로 테스트하기 위한 모듈을 제공한다. 단위테스트란 정의된 클래스의 함수 단위로 함수의 반환 값과 기대 값을 비교하여 테스트 하는 것을 말한다.
  - 단위 테스트는 코딩과 동시에 테스트도 할 수 있어 유지보수를 쉽게 할 수 있고 HTTP 프로토콜을 이용한 웹과 앱 연동 및 데이터베이스를 통해 프로그램을 실행 하는 경우 단위별로 결과를 확인할 수 있다.
  - assert문과의 차이는 함수 단위로 테스트 케이스를 만들어 테스트를 수행한다는 점을 들 수 있다. essert문에서 테스트를 하는 경우, 테스트가 이루어지는 모든 곳에 assert문을 작성해야 하지만 unittest는 어디에서 어떤 테스트를 할 것인가의 실행 시점을 수행할 수 있기 때문에 규모가 큰 코드가 프로그램에서 테스트가 가능하다.
  - 테스트는 크게 unittest.TestCase와 unittest.TestSuite로 두 개의 클래스를 통해 정의될 수 있다.
    - unittest.TestCase는 테스트 단위의 수행 시점을 메소드로 제공되는 클래스이다. setUp(self)은 테스트 전에 작업을 수행할 수 있고 테스트 대상의 객체를  생성하거나 확장 모듈을 검사하는 경우에 사용된다. tearDown(self)은 setUp의 반대로 setUp이 성공했다면 테스트 후 처리를 수행한다. 사용방법은 unittest.TestCase를 상속한 클래스에 "test"로 시작되는 함수를 선언하고 assert 문장을 사용하여 조건에 따른 실행 결과를 구현한다.
    - unittest.TestSuite는 unittest.TestCase 혹은 unittest.TestSuite를 가지고 있는 테스트의 큰 단위로 관련 있는 여러개의 테스트 케이스 또는 스위트 들을 모아서 하나의 묶음으로 실행하는 클래스이다. addTest(unittest.TestCase) 메소드로 TestSuite에 TestCase를 추가하고 TestSuite(tuple of TestSuites) 생성자로 여러 개의 TestSuites를 생성한다. 
- 다음과 같이 테스트를 할 수 있다.

![image-20200822123416900](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822123416900.png)

![image-20200822123426272](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822123426272.png)



- 파이썬에서 unittest 모듈의 assert의 주요 관련 메소드이다.
  - self.assertEqual(var1, var2, msg=None) : var 결과 var1와 같은지 확인 후 메시지를 리턴
  - self.assertNotEqual(var1, var2, msg=None) : var 결과 var1와 다를 경우 확인 후 메시지를 리턴
  - self.assertTrue(expr, msg=None) : 결과가 참인 것을 확인 후 메시지 리턴
  - self.assertFaises(exception, func, para, meters, ...) : 예외가 돌아오는지 확인할 수 있다.
- 주요 메소드를 사용한 예이다.

![image-20200822124000042](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822124000042.png)

![image-20200822124010729](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822124010729.png)



------------

#### 모듈

-----------

> 파이썬의 모듈(module)

- 파이썬의 모듈(module)은 코드(code)를 담고 있는 파일로 Python함수(function), 클래스, 전역변수 등과 함께 다른 object들의 group을 정의하는 것을 말한다. 
- 모듈을 사용하는 이유는 다음과 같다.
  - 연관성이 있는 모듈만을 로드하여 프로그램 시작 시간을 줄인다.
  - 필요한 모듈을 손쉽게 추가하여 사용할 수 있다.
  - 별도의 네임스페이스를 가져 독립적으로 작업할 수 있다. 즉 연관된 python object들을 grouping하는 것과 마찬가지로 module들의 이름 충돌 문제들을 피할 수 있게 해준다.
  - module은 python 자체를 관리가 용이하도록 한다. 대부분의 표준 python함수(function)들은 language의 core내에 build되지 않고 필요 시에 load될 수 있도록 특정 module들을y  통해 제공된다.



---------

#### 수학 함수 모듈

---------

> math 모듈 

| 함수                 | 설명                                                         |
| -------------------- | ------------------------------------------------------------ |
| sum(iter[,init])     | sequence 객체 총 합을 리턴(초기값=init)                      |
| max(iter)            | sequence 객체의 최댓값                                       |
| min(iter)            | sequence 객체의 최솟값                                       |
| abs(x)               | x의 절댓값                                                   |
| pow(x,y[,z])         | x**y (z가 있으면, x * *y % z )                               |
| round(x[,n=0])       | x의 반올림(n=0일 때, 소숫점 1자리에서 반올림)                |
| divmod(a,b)          | a/b의 몫과 나머지를 tuple로 리턴                             |
| math.pi              | 원주율                                                       |
| math.e               | 자연상수                                                     |
| math.ceil(x)         | (N >= x)를 만족하는 가장 작은 정수 N을 리턴                  |
| math.floor(x)        | (N <= x)를 만족하는 가장 큰 정수 N을 리턴                    |
| math.trunc(x)        | x의 정수 부분만 리턴                                         |
| math.copysign(x,y)   | y의 부호만 x에 복사해서 리턴                                 |
| math.fabs(x)         | x의 절댓값 리턴                                              |
| math.factorial(x)    | x의 factorial 리턴                                           |
| math.fmod(x,y)       | C library의 fmod 함수 호출<br />항상 피제수 x와 몫의 부호가 동일. 부동소숫점에 추천 |
| math.fsum(iter)      | sequence 객체의 합계 리턴                                    |
| math.modf(x)         | 입력받은 x를 순수 소수부분과 정수부분으로 분리해 tuple로 리턴 분리된 부분은 모두 부호가 할당 |
| math.pow(x,y)        | x**y                                                         |
| math.sqrt(x)         | x의 제곱근                                                   |
| math.exp(x)          | e**x                                                         |
| math.log(x[,base=e]) | base를 밑으로 하는 log                                       |
| math.degrees(x)      | radian을 60분법으로 변환                                     |

- 예제

![image-20200904004714817](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200904004714817.png)

![image-20200904004723819](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200904004723819.png)



> random module

| 함수                                   | 설명                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| random.seed([x])                       | 임의의 숫자 생성시 초기화 작업(x가 None인 경우 시스템 시간 값 사용) |
| random.random()                        | 0.0 <= F < 1.0 사이의 임의의 float 값                        |
| random.uniform(a,b)                    | a, b 사이의 임의의 float 값                                  |
| random.gauss(m, sb)                    | 가우스분포의 난수                                            |
| random.randrange([start,],stop[,step]) | 내장 함수인 range()의 아이템 중 임의로 선택해 리턴           |
| random.randint(a,b)                    | a <= N <=b인 임의의 정수 값                                  |
| random.choice(sequence)                | sequence객체에서 임의의 아이템 리턴                          |
| random.shuffle(x[,random])             | sequence객체 x를 섞음                                        |
| random.sample(populate,k)              | k개만큼 아이템을 populate에서 중복 없이 추출                 |



- 예제

![image-20200904130742849](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200904130742849.png)

![image-20200904130758441](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200904130758441.png)



- 난수를 사용하여 6개의 숫자를 무작위로 추출하는 로또를 구현하는 코드

![image-20200904131149895](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200904131149895.png)

![image-20200904131204193](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200904131204193.png)



> Decimal module

- 파이썬에서 진법 변환 에러에 대해 정확한 결과 값을 얻을 수 있도록 Decimal이라는 모듈을 제공한다.
- Decimal 모듈의 특징
  - 십진법 모듈은 float와 다르게 실수를 정확하게 표현할 수 있다.
  - 양의 무한대(Infinity), 음의 무한대(-Infinity), NaN(Not a Number 연산과정에서 잘못된 입력을 받는 경우)에도 표현할 수 있다.
  - 소수점 자리의 정밀도를 조정할 수 있다.
  - 큰 정밀도를 요하는 연산에도 사용할 수 있다.

- 사용 방법은 Decimal 객체를 이용하여 생성자를 통해 정수, 문자열, 튜플 등으로 값을 전달하여 생성한다.

```python
decimal.Decimal([value[,context]])
```

![image-20200904132043378](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200904132043378.png)

![image-20200904132054621](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200904132054621.png)



- 다음은 rounding의 속성을 이용해서 quantize()내장 함수를 통해 지정된 값을 리턴받는 코드

![image-20200904132612533](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200904132612533.png)

![image-20200904132625906](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200904132625906.png)



- Decimal 객체는 다음과 같은 주요 내장 메소드를 제공한다.

| 메소드         | 설명                                                         |
| -------------- | ------------------------------------------------------------ |
| sqrt()         | decimal의 제곱근 결과를 리턴                                 |
| exp()          | 자연상수(e) ** Decimal결과를 리턴                            |
| ln()           | Decimal의 자연로그 결과를 리턴                               |
| compare(other) | 두 Decimal객체를 비교하여 그 결과를 Decimal객체로 리턴하며 메소드 호출 객체가 더 크면 Decimal('1')을, 같은 경우는 Decimal('0')을, 작은 경우는 Decimal('-1')을 리턴 |
| copy_abs()     | 원본의 절댓값을 갖는 Decimal객체를 리턴                      |
| copy_negate()  | 원본의 음수 값을 갖는 Decimal객체를 리턴                     |
| is_signed()    | 부호 비트가 설정되어 있으면(즉 음수이면) True를 리턴         |
| is_finite()    | 유한수인 경우 True리턴                                       |
| is_infinite()  | 무한수인 경우 True리턴                                       |
| is_zero()      | '0'(+0,-0)인 경우 True 리턴                                  |




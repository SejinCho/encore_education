## 8/20(목) 

> 재귀함수

- 재귀함수는 함수가 직접 또는 간접적으로 자기 자신을 다시 호출하는 것을 말한다. 
- 재귀 호출(recursive call)은 메모리를 많이 소모하게 되며 처리 속도 또한 상대적으로 느리지만 작성하고자 하는 프로그램이 대단히 간결해지며 그 프로그램을 이해하는 것도 쉬워진다.
- 재귀 호출은 Quick sort, Tower of Hanoi, Fractal curve 등의 알고리즘을 구현할 때 많이 사용되며 반드시 종료조건을 명시하고 자신을(함수) 호출하는 구문으로 이루어져 있어야 한다.



- 1부터 n까지의 합을 출력하는 코드를 재귀함수로 작성

![image-20200820091337431](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820091337431.png)

![image-20200820091347206](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820091347206.png)



> 스코핑룰(scoping)

- 스코핑룰이란 파이썬에서 사용되는 함수, 클래스 등이 선언되면 변수를 사용하게 되는데 선언된 변수를 저장할 때 네임스페이스에 저장하고 호출될 때 네임스페이스의 영역의 우선순위에 따라 호출되는 룰을 말한다.
- 파이썬의 네임스페이스는 다음과 같이 세가지로 분류되며 변수가 호출 및 실행되는 우선 순위를 약어를 통해 LGB규칙이라고 한다.
- LGB는 변수를 찾을 우선순위를 Local -> Global -> Built-in의 순을 가진다.
  - Local(지역) : 함수 내부에 선언될 때의 영역을 말한다.
  - Global(전역) : 함수 외부에 선언될 때의 영역을 말한다.
  - Built-in(내장) : 파이썬에서 제공하는 함수의 영역을 말한다.



- func() 함수에서 변수 x를 호출하게 되면 전역 변수가 우선순위가 있어 50을 출력하게 된다. 마지막 라인에서 print(x)를 호출하게 되면 함수 내에 있는 global 변수는 2를 저장하여 전역 변수 값인 2가 출력된다.

![image-20200820092458666](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820092458666.png)

![image-20200820092511487](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820092511487.png)



![image-20200820093047836](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820093047836.png)

![image-20200820093100351](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820093100351.png)







---------------

#### 클래스(Class)

-------

> OOP(Object Oriented Programming)와 클래스(Class)

- OOP이란 객체 지향프로그램을 말하며 데이터 처리를 하는 메소드들을 하나의 프로그램으로 설계해서 연동하는 객체(Object)를 중심으로 프로그램을 짜는 언어를 말한다. Python은 대화적이고(interactive), 인터프리팅(interpreted)되는 객체 지향(object-oriented) 프로그래밍 언어이다.
- 클래스(Class)는 객체지향 프로그램의 기본적인 사용자 정의 데이터형(user define data type)이라고 할 수 있다. 클래스는 객체를 정의한 것으로 실세계에서 존재하는 사물이나 개념의 속성과 기능을 모델링해서 추상화 시키는 과정을 말한다.
- 객체는 자신의 고유의 속성(attribute)을 가지며 클래스에서 정의한 행위(behavior)를 수행할 수 있다. 
- 객체의 행위는 클래스에 정의된 행위에 대한 정의를 공유함으로써 메모리를 경제적으로 사용한다.
- 객체는 클래스의 인스턴스이며 정의된 클래스를 사용해서 실제로 메모리에 생성되어 메모리에 로딩된 상태를 말한다.

- 객체지향 프로그래밍적인 관점에서 객체는 클래스의 타입으로 선언되었을 때를 의미하는 것이고, 그 객체가 메모리에 할당되어 실제 사용될 때를 '인스턴스' 라고 하는 것이다. 즉, 인스턴스는 추상화 개념 또는 클래스 객체, 컴퓨터 프로세스 등과 같은 템플릿이 실제 구현된 것이다.
- 객체와 클래스는 다음과 같이 분류될 수 있다.
  - 객체 = 속성(Attributes) + 행위(Behaviors)
  - 클래스 = 변수(Variable) + 메소드(Methods)

- 파이썬 클래스는 다음과 같은 특징을 갖는다.
  - public 멤버
    - 기본적으로 모든 클래스 멤버들은 public이며, 함수들은 동적 바인딩(C++에서의 virtual 함수)이다.
    - 오브젝트 함수에서 자바의 this와 같은 오브젝트 멤버를 접근하는 내부 연산자가 없고 모든 함수의 첫 인자가 self 키워드로 선언한다.
  - method object
    - 데이터 속성(attribute)이 아닌 인스턴스의 속성이 소스 코드 내에서 언급되면, 인터프리터는 우선 그 인스턴스의 클래스를 찾아본다.
    - 만야 그 속성이 클래스의 유효한 함수 오브젝트라면, 인스턴스 오브젝트와 함수 오브젝트를 추상 오브젝트로 packing 하는데, 이것을 메소드 오브젝트라고 부른다.
  - private 멤버
    - 기본적으로 파이썬은 private함수나 변수를 키워드를 통해 명시적으로 지원하지 않지만 관습적으로(conventionally) 더블 언더스코어(__)로 시작하는 이름은 non-public으로 취급된다.
    - subclass에서 동일하 ㄴ이름으로 선언된 변수처럼 private 멤버의 필요성으로 인해 name mangling이라는 방법으로 private variable을 지원한다.
    - " _ _ "로 시작하는 모든 이름들은 "_클래스명__이름"의 형식으로 변환된다.



> 클래스 선언과 생성

- 클래스는 자료형 선언 -> 객체 생성 -> 멤버 호출로 이루어진다.
- 클래스의 선언 방법

```
class 클래스이름 [(상속 클래스 명)] :
	
	< 클래스 변수 선언 >
	
	def 클래스 함수 (self [ 인수1, 인수2, ...]) :
		<수행할 문장>		
```

- 'self' : 파이썬 만의 독특한 변수로 클래스 내에서 정의되는 함수는 무조건 첫 번째 인자로 self를 사용하여야 한다.
- 클래스 내에 정의된 함수를 메소드(method) 라고 한다.



_[Step 1] 클래스 선언_

- 값은 받아 저장하는 멤버를 가진 메소드는 empty()라고 명명하고, 값을 받아 추가하는 메소드는 add() 메소드라고 명명한다고 설계한 다음 클래스 다이어그램과 Test라는 클래스를 선언해보자

![image-20200820101422823](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820101422823.png)

- 클래스 선언

![image-20200820101712656](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820101712656.png)



_[Step 02] 클래스 객체 생성_

- Test 클래스가 정의되면 클래스 객체 생성을 통한 인스턴스를 만드는 것은 다음과 같다.

![image-20200820102019420](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820102019420.png)

![image-20200820102141132](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820102141132.png)



_[Step 03] 참조된객체의 멤버를 호출해서 사용한다._

![image-20200820102310357](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820102310357.png)

![image-20200820102352375](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820102352375.png)

- 전체 코드를 확인하고 실행 결과 확인

![image-20200820102710939](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820102710939.png)

![image-20200820102726609](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820102726609.png)



- 메소드에서 지정하는 self의 의미는?
  - 파이썬의 클래스 안에 선언되는 메소드 선언 시 꼭 명시해야 하는 인수는 self이다. self는 다음과 같은 의미를 가진다.
  - 파이썬에서 매개인자 중 메소드를 정의할 때 첫 번째 매개인자를 반드시 명시하게 되는데 self인수라고 부른다,
  - self인수의 의미는 객체자신의 참조이다.
  - 모든 메소드는 최소한 self 인수는 가져야 한다. (예외가 있음)
  - 객체를 통해서 불려지는 메소드의 첫 번째 인수는 자동적으로 객체의 참조로 채워진다. 따라서 self 인수를 넘겨 줄 필요는 없다.
  - self를 통해서 클래스 내의 멤버나 메소드를 자유롭게 호출할 수 있다.



- 이름과 주소 전화번호를 관리하는 Address라는 클래스를 선언하고 호출하는 방법

![image-20200820104357232](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820104357232.png)

![image-20200820104411415](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820104411415.png)



- 선언된 Address 클래스를 이용하여 다음과 같은 여러 명의 주소록의 내용을 담아 관리하려고 한다면 객체를 생성해서 값을 저장하면 된다. (선언 -> 객체 생성 -> 값 대입)

| 이름     | 주소  | 전화번호     |
| -------- | ----- | ------------ |
| Dominico | Seoul | 010-111-2222 |
| Dominica | Busan | 010-232-2323 |

![image-20200820105208798](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820105208798.png)

![image-20200820105219110](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820105219110.png)



- 예제 (계산기)

![image-20200820115125983](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820115125983.png)

![image-20200820115139089](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820115139089.png)



> _ _ class _ _ 키워드와 private 멤버

- _ _ class_ _ 키워드 : 인스턴스 객체가 자신을 생성한 클래스 객체를 참조하기 위하여 파이썬에서는 인스턴스 객체의 내장속성 '_ _ class_ _ '를 제공한다.
- 테이블의 데이터를 이용해 Emp라는 클래스를 만들어 변수를 두 개 선언한 후 a1, a2, a3의 객체를 각각 생성해서 한 줄씩 데이터를 사원번호로 구분되어 저장한 다음 출력

| 사원번호 | 7월 영업실적 |
| -------- | ------------ |
| a111     | 850          |
| b111     | 750          |
| c111     | 650          |

![image-20200820111423449](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820111423449.png)

![image-20200820111447256](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820111447256.png)



- 위의 코드에서 다음을 추가한 후 실행 결과를 보면  _ _ class _ _는 인스턴스가 속하는 클래스를 나타내는 것을 확인할 수 있다.

![image-20200820111705437](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820111705437.png)

![image-20200820111715216](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820111715216.png)



- 파이썬에 클래스의 멤버 선언 시 더블 언더스코어는 private이다. 즉, Test02의 메소드간의 내부호출로 같은 클래스 내에 k() 메소드는 호출은 가능하나 객체를 생성하거나 상속 시에 호출할 수 없다. 정보 은닉인 멤버변수 보호의 캡슐화가 구현된다.

![image-20200820142255258](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820142255258.png)

![image-20200820142359583](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820142359583.png)



> 클래스의 내장함수

- 클래스의 내장함수는 크게 인스턴스의 생성자와 소멸자, 연산자 오버로드, 문자열과 기본 자료형이 튜플, 리스트, 셋 등에서 사용한 인덱싱 관련 함수 등의 세가지로 나눈다.



- 생성자와 소멸자

  - init 메소드("초기화(initialization)"의 줄임말)는 객체가 인스턴스화 될 때 호출되는 특수 메소드(special method)로 완전한 이름은 __ init __ 이다. 내장함수의 형식은 모두 동일하게 함수의 이름 앞뒤로 버블언더 스코어로 선언된다.

  - __ del __은 인스턴스가 소멸될 때 호출되는 소멸자(destructor)이다.

    | 함수       | 설명                                             |
    | ---------- | ------------------------------------------------ |
    | __ init __ | 생성자(Constructor), 인스턴스가 만들어질 때 호출 |
    | __ del __  | 소멸자(Destructor), 인스턴스가 사라질 때 호출    |

  - __ init __은 새로운 클래스의 인스턴스가 만들어질 때 자동적으로 불려지는 생성자(constructor)로 다른 내장함수와는 다르게 명시적으로 호출할 수 없다.

  - 따라서 변수의 초기화 작업 등으로 사용할 수 있고 __ del __은 인스턴스가 소멸될 때 del함수를 통해 호출되어 실행되기 때문에 오픈된 작업파일을 클로즈 하거나 데이터 베이스 연결을 종료하는 등의 리소스 해제 작업코드를 작성할 때 사용한다.

  

- 생성자를 구현한 프로그램이다. 내부적으로 제공되는 메소드를 이용하여 생성자를 통해 객체생성시 멤버의 값 전달을 살펴보자.

![image-20200820144158821](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820144158821.png)

![image-20200820144356951](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820144356951.png)





- 소멸자를 살펴보자. 리소스 해제 되어 호출되는 소멸자는 다음과 같이 실행을 확인해 볼 수 있다.

![image-20200820145140684](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820145140684.png)

![image-20200820145202162](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820145202162.png)

- Res를 호출하게 되면 소멸되었기 때문에 정의되어 있지 않다는 Error를 확인할 수 있다.



- 연산자 오버로딩
  - 연산자 오버로딩이란 operator 키워드와 연산자를 겹쳐서 함수명으로 사용하는 것을 말한다. 
  - 즉, 연산자의 기능을 가진 함수를 지칭하는 인스턴스 객체끼리 서로 연산을 할 수 있게끔 기존에 있는 연산자의 기능을 바꾸어 중복으로 정의하는 것을 말한다.
  - 단, 연산자 오버로딩은 삼항 연산을 할 수 없다. 

| 메소드(Method)             | 연산자(Operator) | 사용 예         |
| -------------------------- | ---------------- | --------------- |
| __ add __ (self,other)     | + (이항)         | A + B, A += B   |
| __ pos __(self)            | + (단항)         | + A             |
| __ sub __(self,other)      | - (이항)         | A - B, A +-= B  |
| __ neg __(self)            | - (단항)         | - A             |
| __ mul __(self)            | *                | A * B, A *= B   |
| __ truediv __(self,other)  | /                | A / B, A /= B   |
| __ floordiv __(self,other) | //               | A //B, A //= B  |
| __ mod __(self,other)      | %                | A % B, A %= B   |
| __ pow __(self,other)      | pow(), **        | pow(A, B), A**B |
| __ lshift __(self,other)   | <<               | A << B, A <<= B |
| __ rshift __(self,other)   | ''>>             | A >> B, A >>=B  |
| __ and __(self,other)      | &                | A & B, A &= B   |
| __ xor __(self,other)      | ^                | A ^ B, A \|= B  |
| __ or __(self,other)       | \|               | A \| B, A \|= B |
| __ invert __(self)         | ~                | ~A              |
| __ abs __(self)            | abs()            | abs(A)          |



- 다음과 같이 클래스를 정의하여 연산자 오버로드를 실행해 보자. Num클래스는 값을 받아 멤버변수인 self.Num에 값을 대입하는 생성자와 값을 클래스 내에 미리 정의된 함수인 __ add __ , __ sub __를 중복 정의하였다.

![image-20200820152007662](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820152007662.png)

![image-20200820152021004](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820152021004.png)



------------

#### 클래스 상속

----

> 상속(Inheritance)

- 하나의 객체를 설계할 수 있는 구체(Concrete Class) 또는 단일 클래스를 또 다른 클래스가 기능 추가 및 변경, 특성을 추가하여 새로운 클래스로 정의하는 것을 말한다.
- 기족에 정의된 클래스 즉 구체(Concrete)를 수퍼 클래스(super class), 부모 클래스(Parent class), 선조 클래스(Base class)라고 하며 상속을 받아 기능을 확장하는 클래스를 하위 클래스(Sub class), 자속, 후손 클래스(Child class), 파생 클래스(Derived class)라고 부른다.
- 상속의 특징은 다음과 같다
  - 선조가 후손에게 재산을 상속하듯이 클래스가 또 다른 클래스에게 상속을 할 수 있다.
  - 클래스 간의 상속은 멤버변수와 메소드를 또 다른 클래스에게 그대로 전해주며 후손은 선조의 메소드를 후손에서 선조의 멤버를 호출할 때는 '선조클래스명.멤버'로 호출이 가능하다.
  - 후손 클래스는 선조 클래스로부터 멤버 변수와 메소드를 상속받지만 생성자는 상속 받을 수 없다.
  - 파이썬 상속의 목적은 코드의 재사용성, 간결성, 확장성을 제공하는 것이다.



> 상속의 선언 방법

- 선조 클래스와 후손 클래스는 후손 클래스를 선언할 때 괄호 안에 선조 클래스 명을 선언하게 되면 상속이 이루어 진다. 
- 파이썬 상속은 선조 클래스가 하나 이상인 다중 상속을 지원한다.
- 다중 상속 시에는 콤마로 나열해서 선조의 클래스 명을 지정한다.

```
[형식]
class 후손 클래스명 (선조 클래스명, 선조 클래스명):
	<<코드>>
```



- 다음과 같은 상속구조를 살펴보자. 이름과 나이를 관리하는 Person클래스를 Student 클래스가 상속을 받아 학년만 추가해서 이름, 나이, 학년을 모두 출력하는 클래스이다.
- Student는 선조인 Person이라는 클래스에서 이름과 나이를 입력 받아 출력하기 때문에 상속을 받아 메소드를 호출해서 사용한다. def  __ init __ (self,name,age,grade_):의 생성자를 통해 선조에게 전달할 이름과 나이, 학년을 입력 받아 이름과 나이는 선조인 Person에게 전달할 Person.__ init __ (self, name, age)를 호출하고 self.grade = grade는 student의 멤버변수에게 전달한다.
- def GetStudent(self) : 메소드에서는 return self.PersonInfo() + ", grade : " + str(self.grade)의 코드로 선조의 메소드를 상속받아 self라는 키워드를 통해 self.PersonInfo() 메소드를 호출하게 되면 이름과 나이를 리턴받게 된다.

![image-20200820173357800](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820173357800.png)

![image-20200820173408369](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820173408369.png)



> super()

- super() 키워드는 선조 클래스(super class)를 의미하며 self키워드는 현재 오프젝트를 지징하는 후손(subclass)를 의미한다.
- super 키워드의 특징은 다음과 같다
  - super() 키워드는 명시적으로 후손 클래스에서 선조의 변수나 메소드를 가리킬 때 사용 된다.
  - 후손 클래스에서 후손이 가진 값을 선조 클래스의 생성자를 호출해서 대입하려면 super() 키워드를 이용하면 된다.
- super() 키워드는 다음과 같이 후손 클래스의 코드를 변경해서 사용할 수 있다.

![image-20200820174213297](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200820174213297.png)



> 오버라이딩(Overriding)

- 메소드 재정이라고도 하며 상속받은 후손 클래스에서 상속해 준 선조 클래스에 이미 정의되어 있는 매소드의 기능을 변경해서 새로 정의하는 것을 말한다.
- 오버라이딩의 특징은 다음과 같다.
  - 오버라이드가 하고자 하는 메소드가 선조 클래스에 존재해야 한다.
  - 선조에서 선언한 메소드가 후손에서 사용할 때 메소드 명이 반드시 같아야 한다.
  - 하나의 클래스에 같은 메소드를 선언하는 선조가 정의한 메소드의 파라미터 개수가 같아야 한다.
  - 파이썬에서는 메소드의 리턴 형이 같지 않아도 된다.

- 메소드의 네임 밸류를 클래스에서 가지게 된다면 상속관계를 가지거나 여러가지 클래스를 사용할 때 편리하게 호출할 수 있을 것이다. 클래스의 생성자는 모든 클래스에서 사용할 때 __ init __로 선언하게 된다. 
- 다음은 꼭 오버라이딩을 해야하는 경우의 프로그램이다.
- 성적계산을 할 때 총점을 리턴하는 메소드를 getTot()로 만들어 놓고 계산

![image-20200822102444483](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822102444483.png)

![image-20200822102506189](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822102506189.png)



> 다중상속

- python은 상속 시 하나 이상의 선조를 가질 수 있는 다중상속을 지원한다.
- 다중 상속 시 발생하는 문제 중에 하나는 두 개 이상의 부모가 같은 메소드를 가지고 있을 때인데 python은 먼저 정의된 쪽이 호출된다.

![image-20200822102700377](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822102700377.png)



- 예제

![image-20200822102923886](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822102923886.png)

![image-20200822102930797](C:\Users\whtpw\AppData\Roaming\Typora\typora-user-images\image-20200822102930797.png)



















